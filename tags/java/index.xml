<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on NereusYi</title><link>https://g.nereusyi.com/tags/java/</link><description>Recent content in java on NereusYi</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 05 Feb 2020 21:28:09 +0800</lastBuildDate><atom:link href="https://g.nereusyi.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>visualvm的profiler连接问题</title><link>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</link><pubDate>Wed, 05 Feb 2020 21:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</guid><description>在 Windows 10 上，用JDK8 自带的jvisualvm.exe连接java程序，出现了几个问题。
问题1：选择profiler分析的时候，一直卡在“正在连接目标VM”： 解决：在命令行中用以下命令启动：
jvisualvm.exe -J-Dorg.netbeans.profiler.separateConsole=true 用这个方法启动过一次，第二次就可以直接双击启动，不用再从命令行启动了。
问题2：使用上面方法启动之后，再次选择profiler分析，出现Redefinition failed with error 62 解决：在被分析的程序启动时，加上JVM参数：-Xverify:none。
JDK内置的visualvm版本比较老，以上问题在我从官网上下载新的1.4.4版本的visualvm后都正常了。在JDK9之后，JDK也不再内置visualvm，所以还是单独下一个备着会比较好。
参考：
https://stackoverflow.com/questions/37632783/visualvm-cpu-memory-profiler-stuck-at-connecting-to-the-target-jvm
https://github.com/oracle/visualvm/issues/33
https://visualvm.github.io
https://blogs.oracle.com/java-platform-group/visual-vm-in-jdk-9-and-beyond</description></item><item><title>Orika使用实例</title><link>https://g.nereusyi.com/post/2019/orika-example/</link><pubDate>Sat, 07 Dec 2019 13:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/orika-example/</guid><description>简述 在项目中使用过不少Java Bean映射（Java Bean属性拷贝）类库，比如Apache和Spring的BeanUtils，cglib的BeanCopier等。 Apache和Spring的BeanUtils没有对list拷贝的内置支持，对属性不同类型的转换也缺乏默认的支持，需要做不少封装。 cglib的BeanCopier的API相对来说比较难使用，虽然速度极快，但需要做更多的封装，可读性不好。
综合下来，发现Orika能较好的满足各项常见的Java Bean映射需求。
使用实例 在实际使用中，通常可以把Orika封装成一个静态工具类，示例如下：
public class BeanMapperUtils { private static final DefaultMapperFactory mapperFactory ; private static final MapperFacade mapper; static { mapperFactory = new DefaultMapperFactory.Builder().build(); mapper = mapperFactory.getMapperFacade(); } public static &amp;lt;S, D&amp;gt; D map(S s, Class&amp;lt;D&amp;gt; aClass) { return mapper.map(s, aClass); } public static &amp;lt;S, D&amp;gt; List&amp;lt;D&amp;gt; mapAsList(Iterable&amp;lt;S&amp;gt; iterable, Class&amp;lt;D&amp;gt; aClass) { return mapper.mapAsList(iterable, aClass); } } MapperFactory和MapperFacade都是线程安全的，可以使用单例模式。详情可参考官方文档的Use the MapperFactory as a singleton章节。</description></item><item><title>动手实现:用Java实现一个简单的LinkedList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</link><pubDate>Sat, 24 Aug 2019 17:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</guid><description>概述 LinkedList也是List接口的一个实现，采用线性链表存储元素。本文尝试编写一个简单的LinkedList实现，通过对比来理解JDK中的LinkedList是如何实现的。本次主要实现LinkedList的一些常用方法。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。</description></item><item><title>动手实现:用Java实现一个简单的ArrayList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</link><pubDate>Thu, 30 May 2019 23:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</guid><description>概述 ArrayList是一个可以自动扩容的List接口实现，由命名可以看出是由数组实现。本文尝试编写一个简单的ArrayList实现，通过对比来理解JDK中的ArrayList是如何实现的。本次主要实现ArrayList的常用方法，完成简单的CRUD和迭代器。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。</description></item></channel></rss>