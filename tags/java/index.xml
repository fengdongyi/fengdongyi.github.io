<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on NereusYi</title><link>https://g.nereusyi.com/tags/java/</link><description>Recent content in java on NereusYi</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 10 Feb 2020 20:15:06 +0800</lastBuildDate><atom:link href="https://g.nereusyi.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java微型网络程序GC调优练习</title><link>https://g.nereusyi.com/post/2020/02/gc-tuning-practice/</link><pubDate>Mon, 10 Feb 2020 20:15:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/02/gc-tuning-practice/</guid><description>简介 最近用java写了一个微型的网络程序，没进行GC调优的情况下就已经满足性能要求。不过想通过对这个程序调优，再熟悉一下GC调优流程。
通过活跃数据大小设置堆内存大小 活跃数据大小指的是应用程序员运行于稳定态时，长期存活的对象在Java堆中占用的空间大小。所以可以在程序稳定运行时，进行多次Full GC，之后再查看Java堆的占用情况来测量活跃数据大小。
调优过程需要一步一步多次确定更合适的值，JVM的初始参数和版本信息如下（堆大小按感觉先随意分配256M，如果有溢出再调整）：
-Xms256m -Xmx256m -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:MaxDirectMemorySize=512m -XX:+PrintCommandLineFlags -XX:+UseParallelGC java version &amp;quot;1.8.0_241&amp;quot; Java(TM) SE Runtime Environment (build 1.8.0_241-b07) Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode) 其中-XX:+PrintGCDetails参数表示打印垃圾回收情况，-XX:+PrintGCTimeStamps参数表示每次打印的时候带上JVM启动到当前时间的秒数，也可以使用-XX:+PrintGCDateStamps打印日历时间。-XX:+UseParallelGC是java8在Windows64上的默认选择，表示同时启用多线程新生代和多线程老年代的Parallel垃圾收集器[1]，这一点可能跟旧版本的java不一样（对旧版本java的没太多研究）。
用这个程序来看平均速率在200KB/S左右的直播。运行一段时间之后，程序达到稳定状态。由于这个程序在256M内存下，不经常发生Full GC，所以在程序稳定运行的时候，用visualvm触发多次Full GC。每次Full GC的结果比较相似，选取其中一个显示如下（已调整换行）：
1887.144: [Full GC (System.gc()) [PSYoungGen: 224K-&amp;gt;0K(86528K)] [ParOldGen: 7438K-&amp;gt;6220K(175104K)] 7662K-&amp;gt;6220K(261632K), [Metaspace: 19356K-&amp;gt;19356K(1067008K)], 0.0254513 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 日志显示，Full GC之后的老年代占用6220K，所以活跃数据大约为6M。根据通用法则，堆的初始值和最大值一般设置为老年代活跃数据大小的3-4倍。这里按4倍计算，设置堆的初始值和最大值为24M：-Xms24m -Xmx24m。
而新生代的空间应该为老年代活跃数据的1-1.5倍。这里按1.5倍计算，设置新生代大小为9M：-Xmn9m。调整后使用的JVM参数设置如下：
-Xms24m -Xmx24m -Xmn9m -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:MaxDirectMemorySize=512m -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC 验证设置 经过设置之后，再次让程序运行到稳定的状态。其中Minor GC的频率比较稳定，摘取结果如下：</description></item><item><title>visualvm的profiler连接问题</title><link>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</link><pubDate>Wed, 05 Feb 2020 21:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</guid><description>在 Windows 10 上，用JDK8 自带的jvisualvm.exe连接java程序，出现了几个问题。
问题1：选择profiler分析的时候，一直卡在“正在连接目标VM”： 解决：在命令行中用以下命令启动：
jvisualvm.exe -J-Dorg.netbeans.profiler.separateConsole=true 用这个方法启动过一次，第二次就可以直接双击启动，不用再从命令行启动了。
问题2：使用上面方法启动之后，再次选择profiler分析，出现Redefinition failed with error 62 解决：在被分析的程序启动时，加上JVM参数：-Xverify:none。
JDK内置的visualvm版本比较老，以上问题在我从官网上下载新的1.4.4版本的visualvm后都正常了。在JDK9之后，JDK也不再内置visualvm，所以还是单独下一个备着会比较好。
参考：
https://stackoverflow.com/questions/37632783/visualvm-cpu-memory-profiler-stuck-at-connecting-to-the-target-jvm
https://github.com/oracle/visualvm/issues/33
https://visualvm.github.io
https://blogs.oracle.com/java-platform-group/visual-vm-in-jdk-9-and-beyond</description></item><item><title>Orika使用实例</title><link>https://g.nereusyi.com/post/2019/orika-example/</link><pubDate>Sat, 07 Dec 2019 13:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/orika-example/</guid><description>简述 在项目中使用过不少Java Bean映射（Java Bean属性拷贝）类库，比如Apache和Spring的BeanUtils，cglib的BeanCopier等。 Apache和Spring的BeanUtils没有对list拷贝的内置支持，对属性不同类型的转换也缺乏默认的支持，需要做不少封装。 cglib的BeanCopier的API相对来说比较难使用，虽然速度极快，但需要做更多的封装，可读性不好。
综合下来，发现Orika能较好的满足各项常见的Java Bean映射需求。
使用实例 在实际使用中，通常可以把Orika封装成一个静态工具类，示例如下：
public class BeanMapperUtils { private static final DefaultMapperFactory mapperFactory ; private static final MapperFacade mapper; static { mapperFactory = new DefaultMapperFactory.Builder().build(); mapper = mapperFactory.getMapperFacade(); } public static &amp;lt;S, D&amp;gt; D map(S s, Class&amp;lt;D&amp;gt; aClass) { return mapper.map(s, aClass); } public static &amp;lt;S, D&amp;gt; List&amp;lt;D&amp;gt; mapAsList(Iterable&amp;lt;S&amp;gt; iterable, Class&amp;lt;D&amp;gt; aClass) { return mapper.mapAsList(iterable, aClass); } } MapperFactory和MapperFacade都是线程安全的，可以使用单例模式。详情可参考官方文档的Use the MapperFactory as a singleton章节。</description></item><item><title>动手实现:用Java实现一个简单的LinkedList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</link><pubDate>Sat, 24 Aug 2019 17:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</guid><description>概述 LinkedList也是List接口的一个实现，采用线性链表存储元素。本文尝试编写一个简单的LinkedList实现，通过对比来理解JDK中的LinkedList是如何实现的。本次主要实现LinkedList的一些常用方法。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。</description></item><item><title>动手实现:用Java实现一个简单的ArrayList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</link><pubDate>Thu, 30 May 2019 23:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</guid><description>概述 ArrayList是一个可以自动扩容的List接口实现，由命名可以看出是由数组实现。本文尝试编写一个简单的ArrayList实现，通过对比来理解JDK中的ArrayList是如何实现的。本次主要实现ArrayList的常用方法，完成简单的CRUD和迭代器。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。</description></item></channel></rss>