<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on NereusYi</title><link>https://g.nereusyi.com/tags/java/</link><description>Recent content in java on NereusYi</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 04 Dec 2021 12:50:11 +0800</lastBuildDate><atom:link href="https://g.nereusyi.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>让Quartz Scheduler在小写表名下运行</title><link>https://g.nereusyi.com/post/2021/12/quartz-scheduler-lower-table-name/</link><pubDate>Sat, 04 Dec 2021 12:50:11 +0800</pubDate><guid>https://g.nereusyi.com/post/2021/12/quartz-scheduler-lower-table-name/</guid><description>简介 在使用Quartz框架时，框架内的sql语句都是使用大写的表名来操作，但是在公司内统一小写并且开启了大小写敏感的情况下，Quartz就会报错。Quartz官方也不打算提供可配置的大小写选项，只是说开启数据库大小写不敏感就可以解决[1]。在很多情况下，公司内的规范都不是个人能轻易改变的，所以比较靠谱的方法就是改Quartz框架的代码。还好框架提供了足够的扩展点，让使用者可以解决这个问题。
修改sql执行类的配置 与sql执行相关的配置有tablePrefix、driverDelegateClass和lockHandler.class，其中后两项是使用新的实现替换框架内置的实现。新的实现可以直接使用Quartz框架的，只需要把类中对应的表名大写改成小写即可，可参考基于Spring Boot的示例工程[2]。不过需要注意的是目前我只使用到了基于Cron的调度功能，所以如果有使用其他实现，需要再对示例工程做一些相应的修改。
基于Spring Boot的application配置示例：
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/quartz_demo spring.datasource.username=root spring.datasource.password=root spring.quartz.job-store-type=jdbc spring.quartz.properties.org.quartz.jobStore.tablePrefix=qrtz_ spring.quartz.properties.org.quartz.jobStore.driverDelegateClass=com.nereusyi.demos.quartz.StdJDBCDelegate spring.quartz.properties.org.quartz.jobStore.lockHandler.class=com.nereusyi.demos.quartz.StdRowLockSemaphore 参考资料 [1]quartz-scheduler github issues：https://github.com/quartz-scheduler/quartz/issues/31
[2]示例工程：https://github.com/nereusyi/quartz-lower-table-name</description></item><item><title>加快Maven的构建速度</title><link>https://g.nereusyi.com/post/2021/11/speed-up-maven-build/</link><pubDate>Sun, 07 Nov 2021 12:50:11 +0800</pubDate><guid>https://g.nereusyi.com/post/2021/11/speed-up-maven-build/</guid><description>简介 对于CI/CD服务器，需要频繁对maven项目进行构建。我们可以基于这样的场景，使用一些技术加快maven构建速度。
使用所有cpu进行构建 默认情况下，maven只使用一个线程进行构建，但对于有多核cpu的CI/CD服务器来说，这样就有些浪费cpu资源了。这时可以通过Maven 3的并行构建来充分利用多核的性能，加速maven的构建。
构建命令：
mvn -T 1C clean install 设置-T 1C表示每个CPU一个线程。
这对于有多个模块并且没有依赖关系的大型项目来说，能极大的加快构建速度。更详细的资料可见参考资料1。
后台运行Maven maven每次启动构建，JVM都需要重新加载相关的类，初始化相关的环境。对于CI/CD服务器来说，频繁构建就导致频繁的JVM初始化，会消耗大量时间。基于这样的场景，社区开发了maven daemon项目。
该项目的目的是让maven一直运行在后台，这样就可以免去不少maven构建时的初始化步骤。还有该项目使用了GraalVM，也就是说maven daemon是直接以本地二进制代码执行的，执行效率和内存占用相对传统JVM来说更有优势。
maven daemon使用起来也很简单，跟普通的mvn命令一样，只需要把mvn改成mvnd就可以（不同环境的安装方法，可见参考资料2的官方文档）：
mvnd clean install maven daemon默认就是以多线程的方式运行，所以不需要再额外设置参数。
参考资料 [1]Parallel builds in Maven 3：https://cwiki.apache.org/confluence/display/MAVEN/Parallel+builds+in+Maven+3
[2]mvn daemon：https://github.com/mvndaemon/mvnd</description></item><item><title>增强Java8和11的空指针异常提示</title><link>https://g.nereusyi.com/post/2021/08/enhance-jvm-8-and-11-with-npe/</link><pubDate>Sun, 29 Aug 2021 22:15:11 +0800</pubDate><guid>https://g.nereusyi.com/post/2021/08/enhance-jvm-8-and-11-with-npe/</guid><description>简介 在Java14之前，如果出现NullPointerException,只会知道有对象为null导致空指针，如果在多个对象上调用了方法，那么就很难区分到底哪个对象为null。在 Java14中，JEP 358（详情见参考资料1）的出现改善了这样的情况，丰富了NullPointerException的输出，但目前常用的版本还是Java8或11等长期支持的版本，所以下面介绍一种方法来让8和11也能实现更加丰富的NullPointerException提示。
增加空指针异常提示 示例代码如下：
public static void main(String[] args) { Map&amp;lt;String, String&amp;gt; map = null; demo(map); } public static void demo(Map&amp;lt;String,String&amp;gt; map){ System.out.println(map.get(&amp;#34;foo&amp;#34;).toLowerCase()); } 8和11在增强之前的输出如下：
Exception in thread &amp;#34;main&amp;#34; java.lang.NullPointerException at com.nereusyi.npe.NpeDemo.demo(NpeDemo.java:18) at com.nereusyi.npe.NpeDemo.main(NpeDemo.java:14) 并没有什么有用的信息，根据这段异常也没法判断到底是哪个对象为null。
下面就可以开始动手增强异常提示了，我们可以在https://github.com/odnoklassniki/jvmti-tools/tree/master/richNPE中找到增强异常提示的代码，具体使用方法也在首页中有详细说明。
下载该文件之后，需要手动编译该文件，首页中少了Mac的编译命令，我在这里也补上：
# Linux g++ -O2 -fPIC -shared -I $JAVA_HOME/include -I $JAVA_HOME/include/linux -olibrichNPE.so richNPE.cpp # Windows cl /O2 /LD /I &amp;quot;%JAVA_HOME%/include&amp;quot; -I &amp;quot;%JAVA_HOME%/include/win32&amp;quot; richNPE.cpp # Mac g++ -O2 -fPIC -shared -I $JAVA_HOME/include -I $JAVA_HOME/include/darwin -olibrichNPE.</description></item><item><title>Java NIO File API 使用总结 2</title><link>https://g.nereusyi.com/post/2021/06/java-file-nio-demo-2/</link><pubDate>Sun, 20 Jun 2021 18:49:11 +0800</pubDate><guid>https://g.nereusyi.com/post/2021/06/java-file-nio-demo-2/</guid><description>简介 在之前的文章中总结了NIO的Path接口和Files工具类的使用，本文继续总结一些其他的新功能和概念
NIO的基础概念和基本使用 不同于传统的Java File I/O的Stream流的概念，NIO基于Buffer和Channel重新设计了一套API。Buffer的API相对来说比较难用，不过具有零拷贝的功能，可以大大提高文件传输速度。
创建和写入文件 public static void createAndWriteFile(){ ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byteBuffer.put(&amp;#34;HelloWorld&amp;#34;.getBytes(StandardCharsets.UTF_8)); byteBuffer.flip(); try ( FileChannel fileChannel = FileChannel.open(Path.of(&amp;#34;/tmp/test.txt&amp;#34;), StandardOpenOption.CREATE,StandardOpenOption.WRITE) ){ fileChannel.write(byteBuffer); } catch (IOException e) { e.printStackTrace(); } System.out.println(&amp;#34;write success.&amp;#34;); } 可以看到，NIO写入文件前，需要先创建ByteBuffer对象，之后再往里面写入数据。写入之后必须调用flip方法重新设置position和limit，这也是Buffer中的概念。
之后再创建一个Channel，往Channel中写入数据。
读取文件 public static void readFile(){ Charset utf8 = StandardCharsets.UTF_8; ByteBuffer byteBuffer = ByteBuffer.allocate(1024); try ( FileChannel fileChannel = FileChannel.open(Path.of(&amp;#34;/tmp/test.txt&amp;#34;), StandardOpenOption.READ) ){ fileChannel.read(byteBuffer); byteBuffer.flip(); } catch (IOException e) { e.printStackTrace(); } CharBuffer charBuffer = utf8.</description></item><item><title>使用JMH对Java应用进行微基准测试</title><link>https://g.nereusyi.com/post/2020/10/use-jmh-java-benchmark/</link><pubDate>Sun, 25 Oct 2020 14:45:15 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/10/use-jmh-java-benchmark/</guid><description>简介 JMH（Java Microbenchmark Harness）是一个帮助开发者更好的实现微基准测试(microbenchmark)的工具，属于OpenJDK项目的一部分。虽然名字叫微基准测试工具，但JMH也可以适用于其他类型的基准测试，对较大型项目的基准测试同样也有帮助。
为什么需要用JMH来做基准测试 由于JVM会对代码做各种优化，而自己写的基准测试很难考虑到各方面的优化，这样会导致测试的结果可能跟线上的相差较大。JMH本身虽然不能完全消除这些优化的影响，但是它能帮助减轻这方面的影响。
本文使用环境：Java 8
使用Maven构建运行JMH 使用Maven构建运行JMH是被OpenJDK团队推荐的使用方式，因为该方式能产生更加可靠的结果。
使用Maven创建新项目 使用该命令可以创建一个基于Maven的JMH模板项目：
mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jmh -DarchetypeArtifactId=jmh-java-benchmark-archetype -DarchetypeVersion=1.25.2 -DgroupId=com.nereusyi.demos -DartifactId=jmh-template -Dversion=1.0 官方示例的命令行参数中，没有-DarchetypeVersion=1.25.2这行，那样默认会生成较老版本的模板项目，需要较多改动才能适配新版本的Java，所以最好加上该参数。也可以在maven仓库上查看JMH的最新版本并替换
部分输出如下：
[INFO] ---------------------------------------------------------------------------- [INFO] Using following parameters for creating project from Archetype: jmh-java-benchmark-archetype:1.25.2 [INFO] ---------------------------------------------------------------------------- [INFO] Parameter: groupId, Value: com.nereusyi.demos [INFO] Parameter: artifactId, Value: jmh-template [INFO] Parameter: version, Value: 1.0 [INFO] Parameter: package, Value: com.nereusyi.demos [INFO] Parameter: packageInPathFormat, Value: com/nereusyi/demos [INFO] Parameter: package, Value: com.nereusyi.demos [INFO] Parameter: groupId, Value: com.</description></item><item><title>Java NIO File API使用总结</title><link>https://g.nereusyi.com/post/2020/08/java-file-nio-demo/</link><pubDate>Sun, 30 Aug 2020 19:55:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/08/java-file-nio-demo/</guid><description>简介 Java I/O File API是JDK的核心API之一，在构建系统时，十分常用。我在工作实践中，见到大多数人最常使用的是java.io.File的API，对Java7之后出现的NIO的API不太熟悉。
总的来说，File能实现的功能NIO都能实现，并且NIO API更好用、更方便，同时内置了不少工具类，也解决了File API的一些缺陷。
根据实际工作中的使用和一些文档，本文总结了一些常见的Java File NIO的用法。
File的缺陷 File API比较简单好用，能完成大部分功能，但使用上有不少的问题，比如：
大多数方法出错不抛出异常 比如：删除new File(&amp;quot;1111.txt&amp;quot;).delete()，如果删除失败，delete方法只会返回一个false，开发者没办法知道具体原因，比如是因为没权限，还是因为文件已被删除？ 不支持软链接，这会导致有某些情况下没办法遍历目录 文件的元数据支持较少，比如缺少文件的权限、安全属性等 等等。
File和Path java.nio.file.Path是Java7中用于替代File的新API，File和Path的概念相似，都是表示一个文件或文件夹的抽象。实际上，也可以把Path当成新API中的File。
FIle与Path的主要区别：
File是实体类，Path是接口，使得Path更符合面向对象的设计原则。 File独立于文件系统，Path与文件系统相关，以及Path能给出更多关于文件的信息。 新写的代码最好就开始使用Path，有需要与File交互的地方，可以使用FIle与Path相互转换方法：
Path path = new File(DEMO_PATH).toPath(); File file = path.toFile(); Path的基本操作 创建Path URI uri = new URI(&amp;#34;file:///&amp;#34; + DEMO_PATH); // method 1 Path path1 = Paths.get(DEMO_PATH); // method 2 Path path2 = Paths.get(uri); // method 3 Path path3 = Path.of(DEMO_PATH); // method 4 Path path4 = Path.</description></item><item><title>Java8:Time API使用总结</title><link>https://g.nereusyi.com/post/2020/03/java-8-time-api-example/</link><pubDate>Tue, 17 Mar 2020 22:25:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/03/java-8-time-api-example/</guid><description>简介 Java8已经出了很长一段时间，主流的第三方库也都基本已经支持新的Time API，但是见到不少开发还是习惯用Date和Calendar，所以在这篇文章里总结如何使用这个新的Time API，以及旧API的一些设计上的缺陷和使用上的不便。
Date和Calendar的设计 Date设计的开始年份是1900年，月份是从0开始，日又是从1开始，所以想要创建一个2020年1月1日的Date对象得这样：
new Date(120,0,1); 这行代码很难直观看出是想要创建什么时候的Date对象，使用起来十分不便。
Calendar设计年份要好一些，去掉了从1900年开始的设计，但是月份还是从0开始计算，使用起来也是不那么直观：
Calendar calendar = Calendar.getInstance(); calendar.set(2020, 0, 1,0,0,0); 这样的设计和API的不一致，导致不少功能需要各个项目使用utils类来重复实现，或者是使用Joda-Time这样的第三方库。
好在Java8推出了新的Time API，JSR-310来解决这样的情况。新的API与Joda-Time比较相似，但也有一些新的设计。具体可以查看Stephen Colebourne的文章[1]。
Java8的TimeAPI的使用 这一节总结Time包下各个API的使用。
LocalDate、LocalTime和LocalDateTime 这几个类名取得比较好，把这几个类的名字合在一起看，可以比较直观的了解各个类的作用。LocalDate是表示日期的类，LocalTime表示时间，LocalDateTime则表示日期和时间的组合。
使用这几个类创建一个表示日期、时间和日期时间组合的对象也非常直观，注释是打印后的结果：
LocalDate.of(2020, 1, 1);// 2020-01-01 LocalTime.of(0, 0);// 00:00 LocalDateTime.of(2020, 1, 1, 0, 0);// 2020-01-01T00:00 LocalDate.parse(&amp;#34;2020-01-01&amp;#34;);// 2020-01-01 LocalTime.parse(&amp;#34;00:00:00&amp;#34;);// 00:00 LocalDateTime.parse(&amp;#34;2020-01-01T00:00:00&amp;#34;);// 2020-01-01T00:00 这些类不仅使用起来很直观，toString()的结果也很容易看懂。如果要打印Date对象，总是免不了要借助DateFormat类来使打印更容易读懂。需要注意的是，LocalDateTime默认是使用ISO 8601标准，跟国内显示常用的会有些差别。
新的API修改时间也很方便和直观，能直接修改时间的每个节点，也能以某个时间为基点，相对地增加或减少时间，并且每次修改都会返回一个新的对象：
//直接修改 LocalDateTime.parse(&amp;#34;2020-01-01T00:00:00&amp;#34;) .withYear(2010) .withMonth(6) .withDayOfMonth(16);//2010-06-16T00:00 //相对修改 LocalDateTime localDateTime = LocalDateTime.parse(&amp;#34;2020-01-01T00:00:00&amp;#34;); localDateTime.plusDays(6);// 2020-01-07T00:00 localDateTime.plusHours(6);// 2020-01-01T06:00 localDateTime.minusDays(1);// 2019-12-31T00:00 如果有较为复杂的时间修改操作，可以使用TemporalAdjuster类。它的辅助类TemporalAdjusters定义了大量内置常见的复杂修改时间的操作。如果这些内置的方式不能满足需求，也可以自行实现TemporalAdjuster类。
Instant Instant类主要用于描述从Unix元年开始计算的时间，与System.currentTimeMillis()比起来，除了能使用Instant.now().toEpochMilli()来表示Unix元年到现在经过的毫秒数，也能方便使用Instant.now().getEpochSecond()来表示经过秒数，还能使用多种方便的语义化操作。
Duration和Period 这两个对象都是用于表示两个时间的差值，不同点在于Duration不支持LocalDate的差值计算，只支持LocalTime、LocalDateTime和Instant的差值计算。而Period只支持LocalDate的差值计算。一般来说，Duration用于计算两个时间相差的天数、小时数、分钟数、秒数、毫秒数和纳秒数，而Period用于计算相差的天数、月数和年数，如：</description></item><item><title>Java微型网络程序GC调优练习</title><link>https://g.nereusyi.com/post/2020/02/gc-tuning-practice/</link><pubDate>Mon, 10 Feb 2020 20:15:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/02/gc-tuning-practice/</guid><description>简介 最近用java写了一个微型的网络程序，没进行GC调优的情况下就已经满足性能要求。不过想通过对这个程序调优，再熟悉一下GC调优流程。
通过活跃数据大小设置堆内存大小 活跃数据大小指的是应用程序员运行于稳定态时，长期存活的对象在Java堆中占用的空间大小。所以可以在程序稳定运行时，进行多次Full GC，之后再查看Java堆的占用情况来测量活跃数据大小。
调优过程需要一步一步多次确定更合适的值，JVM的初始参数和版本信息如下（堆大小按感觉先随意分配256M，如果有溢出再调整）：
-Xms256m -Xmx256m -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:MaxDirectMemorySize=512m -XX:+PrintCommandLineFlags -XX:+UseParallelGC java version &amp;quot;1.8.0_241&amp;quot; Java(TM) SE Runtime Environment (build 1.8.0_241-b07) Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode) 其中-XX:+PrintGCDetails 参数表示打印垃圾回收情况，-XX:+PrintGCTimeStamps参数表示每次打印的时候带上JVM启动到当前时间的秒数，也可以使用-XX:+PrintGCDateStamps打印日历时间。-XX:+UseParallelGC是java8在Windows64上的默认选择，表示同时启用多线程新生代和多线程老年代的Parallel垃圾收集器[1]，这一点可能跟旧版本的java不一样（对旧版本java的没太多研究）。
用这个程序来看平均速率在200KB/S左右的直播。运行一段时间之后，程序达到稳定状态。由于这个程序在256M内存下，不经常发生Full GC，所以在程序稳定运行的时候，用visualvm触发多次Full GC。每次Full GC的结果比较相似，选取其中一个显示如下（已调整换行）：
1887.144: [Full GC (System.gc()) [PSYoungGen: 224K-&amp;gt;0K(86528K)] [ParOldGen: 7438K-&amp;gt;6220K(175104K)] 7662K-&amp;gt;6220K(261632K), [Metaspace: 19356K-&amp;gt;19356K(1067008K)], 0.0254513 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 日志显示，Full GC之后的老年代占用6220K，所以活跃数据大约为6M。根据通用法则，堆的初始值和最大值一般设置为老年代活跃数据大小的3-4倍。这里按4倍计算，设置堆的初始值和最大值为24M：-Xms24m -Xmx24m。
而新生代的空间应该为老年代活跃数据的1-1.5倍。这里按1.5倍计算，设置新生代大小为9M：-Xmn9m。调整后使用的JVM参数设置如下：
-Xms24m -Xmx24m -Xmn9m -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:MaxDirectMemorySize=512m -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC 验证设置 经过设置之后，再次让程序运行到稳定的状态。其中Minor GC的频率比较稳定，摘取结果如下：</description></item><item><title>visualvm的profiler连接问题</title><link>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</link><pubDate>Wed, 05 Feb 2020 21:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</guid><description>在 Windows 10 上，用JDK8 自带的jvisualvm.exe连接java程序，出现了几个问题。
问题1：选择profiler分析的时候，一直卡在“正在连接目标VM”： 解决：在命令行中用以下命令启动：
jvisualvm.exe -J-Dorg.netbeans.profiler.separateConsole=true 用这个方法启动过一次，第二次就可以直接双击启动，不用再从命令行启动了。
问题2：使用上面方法启动之后，再次选择profiler分析，出现Redefinition failed with error 62 解决：在被分析的程序启动时，加上JVM参数：-Xverify:none。
JDK内置的visualvm版本比较老，以上问题在我从官网上下载新的1.4.4版本的visualvm后都正常了。在JDK9之后，JDK也不再内置visualvm，所以还是单独下一个备着会比较好。
参考：
https://stackoverflow.com/questions/37632783/visualvm-cpu-memory-profiler-stuck-at-connecting-to-the-target-jvm
https://github.com/oracle/visualvm/issues/33
https://visualvm.github.io
https://blogs.oracle.com/java-platform-group/visual-vm-in-jdk-9-and-beyond</description></item><item><title>Orika使用实例</title><link>https://g.nereusyi.com/post/2019/orika-example/</link><pubDate>Sat, 07 Dec 2019 13:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/orika-example/</guid><description>简述 在项目中使用过不少Java Bean映射（Java Bean属性拷贝）类库，比如Apache和Spring的BeanUtils，cglib的BeanCopier等。 Apache和Spring的BeanUtils没有对list拷贝的内置支持，对属性不同类型的转换也缺乏默认的支持，需要做不少封装。 cglib的BeanCopier的API相对来说比较难使用，虽然速度极快，但需要做更多的封装，可读性不好。
综合下来，发现Orika能较好的满足各项常见的Java Bean映射需求。
使用实例 在实际使用中，通常可以把Orika封装成一个静态工具类，示例如下：
public class BeanMapperUtils { private static final DefaultMapperFactory mapperFactory ; private static final MapperFacade mapper; static { mapperFactory = new DefaultMapperFactory.Builder().build(); mapper = mapperFactory.getMapperFacade(); } public static &amp;lt;S, D&amp;gt; D map(S s, Class&amp;lt;D&amp;gt; aClass) { return mapper.map(s, aClass); } public static &amp;lt;S, D&amp;gt; List&amp;lt;D&amp;gt; mapAsList(Iterable&amp;lt;S&amp;gt; iterable, Class&amp;lt;D&amp;gt; aClass) { return mapper.mapAsList(iterable, aClass); } } MapperFactory和MapperFacade都是线程安全的，可以使用单例模式。详情可参考官方文档的Use the MapperFactory as a singleton章节。</description></item><item><title>动手实现:用Java实现一个简单的LinkedList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</link><pubDate>Sat, 24 Aug 2019 17:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</guid><description>概述 LinkedList也是List接口的一个实现，采用线性链表存储元素。本文尝试编写一个简单的LinkedList实现，通过对比来理解JDK中的LinkedList是如何实现的。本次主要实现LinkedList的一些常用方法。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。
然后再看一下get方法的实现
@SuppressWarnings(&amp;#34;unchecked&amp;#34;) @Override public E get(int index) { if(index &amp;lt; 0 || index &amp;gt;= size){ throw new IndexOutOfBoundsException(&amp;#34;索引越界&amp;#34;); } return (E) data[index]; } get方法的实现比较简单，首先检查一下传入索引的合法性，然后再返回数组中对应索引的元素。</description></item><item><title>动手实现:用Java实现一个简单的ArrayList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</link><pubDate>Thu, 30 May 2019 23:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</guid><description>概述 ArrayList是一个可以自动扩容的List接口实现，由命名可以看出是由数组实现。本文尝试编写一个简单的ArrayList实现，通过对比来理解JDK中的ArrayList是如何实现的。本次主要实现ArrayList的常用方法，完成简单的CRUD和迭代器。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。
然后再看一下get方法的实现
@SuppressWarnings(&amp;#34;unchecked&amp;#34;) @Override public E get(int index) { if(index &amp;lt; 0 || index &amp;gt;= size){ throw new IndexOutOfBoundsException(&amp;#34;索引越界&amp;#34;); } return (E) data[index]; } get方法的实现比较简单，首先检查一下传入索引的合法性，然后再返回数组中对应索引的元素。</description></item></channel></rss>