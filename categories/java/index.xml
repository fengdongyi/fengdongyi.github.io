<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on NereusYi</title><link>https://g.nereusyi.com/categories/java/</link><description>Recent content in java on NereusYi</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 20 Jun 2021 18:49:11 +0800</lastBuildDate><atom:link href="https://g.nereusyi.com/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java NIO File API 使用总结 2</title><link>https://g.nereusyi.com/post/2021/06/java-file-nio-demo-2/</link><pubDate>Sun, 20 Jun 2021 18:49:11 +0800</pubDate><guid>https://g.nereusyi.com/post/2021/06/java-file-nio-demo-2/</guid><description>简介 在之前的文章中总结了NIO的Path接口和Files工具类的使用，本文继续总结一些其他的新功能和概念
NIO的基础概念和基本使用 不同于传统的Java File I/O的Stream流的概念，NIO基于Buffer和Channel重新设计了一套API。Buffer的API相对来说比较难用，不过具有零拷贝的功能，可以大大提高文件传输速度。
创建和写入文件 public static void createAndWriteFile(){ ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byteBuffer.put(&amp;#34;HelloWorld&amp;#34;.getBytes(StandardCharsets.UTF_8)); byteBuffer.flip(); try ( FileChannel fileChannel = FileChannel.open(Path.of(&amp;#34;/tmp/test.txt&amp;#34;), StandardOpenOption.CREATE,StandardOpenOption.WRITE) ){ fileChannel.write(byteBuffer); } catch (IOException e) { e.printStackTrace(); } System.out.println(&amp;#34;write success.&amp;#34;); } 可以看到，NIO写入文件前，需要先创建ByteBuffer对象，之后再往里面写入数据。写入之后必须调用flip方法重新设置position和limit，这也是Buffer中的概念。
之后再创建一个Channel，往Channel中写入数据。
读取文件 public static void readFile(){ Charset utf8 = StandardCharsets.UTF_8; ByteBuffer byteBuffer = ByteBuffer.allocate(1024); try ( FileChannel fileChannel = FileChannel.open(Path.of(&amp;#34;/tmp/test.txt&amp;#34;), StandardOpenOption.READ) ){ fileChannel.read(byteBuffer); byteBuffer.flip(); } catch (IOException e) { e.printStackTrace(); } CharBuffer charBuffer = utf8.</description></item><item><title>使用JMH对Java应用进行微基准测试</title><link>https://g.nereusyi.com/post/2020/10/use-jmh-java-benchmark/</link><pubDate>Sun, 25 Oct 2020 14:45:15 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/10/use-jmh-java-benchmark/</guid><description>简介 JMH（Java Microbenchmark Harness）是一个帮助开发者更好的实现微基准测试(microbenchmark)的工具，属于OpenJDK项目的一部分。虽然名字叫微基准测试工具，但JMH也可以适用于其他类型的基准测试，对较大型项目的基准测试同样也有帮助。
为什么需要用JMH来做基准测试 由于JVM会对代码做各种优化，而自己写的基准测试很难考虑到各方面的优化，这样会导致测试的结果可能跟线上的相差较大。JMH本身虽然不能完全消除这些优化的影响，但是它能帮助减轻这方面的影响。
本文使用环境：Java 8
使用Maven构建运行JMH 使用Maven构建运行JMH是被OpenJDK团队推荐的使用方式，因为该方式能产生更加可靠的结果。
使用Maven创建新项目 使用该命令可以创建一个基于Maven的JMH模板项目：
mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=org.openjdk.jmh -DarchetypeArtifactId=jmh-java-benchmark-archetype -DarchetypeVersion=1.25.2 -DgroupId=com.nereusyi.demos -DartifactId=jmh-template -Dversion=1.0 官方示例的命令行参数中，没有-DarchetypeVersion=1.25.2这行，那样默认会生成较老版本的模板项目，需要较多改动才能适配新版本的Java，所以最好加上该参数。也可以在maven仓库上查看JMH的最新版本并替换
部分输出如下：
[INFO] ---------------------------------------------------------------------------- [INFO] Using following parameters for creating project from Archetype: jmh-java-benchmark-archetype:1.25.2 [INFO] ---------------------------------------------------------------------------- [INFO] Parameter: groupId, Value: com.nereusyi.demos [INFO] Parameter: artifactId, Value: jmh-template [INFO] Parameter: version, Value: 1.0 [INFO] Parameter: package, Value: com.nereusyi.demos [INFO] Parameter: packageInPathFormat, Value: com/nereusyi/demos [INFO] Parameter: package, Value: com.nereusyi.demos [INFO] Parameter: groupId, Value: com.</description></item><item><title>Java NIO File API使用总结</title><link>https://g.nereusyi.com/post/2020/08/java-file-nio-demo/</link><pubDate>Sun, 30 Aug 2020 19:55:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/08/java-file-nio-demo/</guid><description>简介 Java I/O File API是JDK的核心API之一，在构建系统时，十分常用。我在工作实践中，见到大多数人最常使用的是java.io.File的API，对Java7之后出现的NIO的API不太熟悉。
总的来说，File能实现的功能NIO都能实现，并且NIO API更好用、更方便，同时内置了不少工具类，也解决了File API的一些缺陷。
根据实际工作中的使用和一些文档，本文总结了一些常见的Java File NIO的用法。
File的缺陷 File API比较简单好用，能完成大部分功能，但使用上有不少的问题，比如：
大多数方法出错不抛出异常 比如：删除new File(&amp;quot;1111.txt&amp;quot;).delete()，如果删除失败，delete方法只会返回一个false，开发者没办法知道具体原因，比如是因为没权限，还是因为文件已被删除？ 不支持软链接，这会导致有某些情况下没办法遍历目录 文件的元数据支持较少，比如缺少文件的权限、安全属性等 等等。
File和Path java.nio.file.Path是Java7中用于替代File的新API，File和Path的概念相似，都是表示一个文件或文件夹的抽象。实际上，也可以把Path当成新API中的File。
FIle与Path的主要区别：
File是实体类，Path是接口，使得Path更符合面向对象的设计原则。 File独立于文件系统，Path与文件系统相关，以及Path能给出更多关于文件的信息。 新写的代码最好就开始使用Path，有需要与File交互的地方，可以使用FIle与Path相互转换方法：
Path path = new File(DEMO_PATH).toPath(); File file = path.toFile(); Path的基本操作 创建Path URI uri = new URI(&amp;#34;file:///&amp;#34; + DEMO_PATH); // method 1 Path path1 = Paths.get(DEMO_PATH); // method 2 Path path2 = Paths.get(uri); // method 3 Path path3 = Path.of(DEMO_PATH); // method 4 Path path4 = Path.</description></item><item><title>Java8:Time API使用总结</title><link>https://g.nereusyi.com/post/2020/03/java-8-time-api-example/</link><pubDate>Tue, 17 Mar 2020 22:25:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/03/java-8-time-api-example/</guid><description>简介 Java8已经出了很长一段时间，主流的第三方库也都基本已经支持新的Time API，但是见到不少开发还是习惯用Date和Calendar，所以在这篇文章里总结如何使用这个新的Time API，以及旧API的一些设计上的缺陷和使用上的不便。
Date和Calendar的设计 Date设计的开始年份是1900年，月份是从0开始，日又是从1开始，所以想要创建一个2020年1月1日的Date对象得这样：
new Date(120,0,1); 这行代码很难直观看出是想要创建什么时候的Date对象，使用起来十分不便。
Calendar设计年份要好一些，去掉了从1900年开始的设计，但是月份还是从0开始计算，使用起来也是不那么直观：
Calendar calendar = Calendar.getInstance(); calendar.set(2020, 0, 1,0,0,0); 这样的设计和API的不一致，导致不少功能需要各个项目使用utils类来重复实现，或者是使用Joda-Time这样的第三方库。
好在Java8推出了新的Time API，JSR-310来解决这样的情况。新的API与Joda-Time比较相似，但也有一些新的设计。具体可以查看Stephen Colebourne的文章[1]。
Java8的TimeAPI的使用 这一节总结Time包下各个API的使用。
LocalDate、LocalTime和LocalDateTime 这几个类名取得比较好，把这几个类的名字合在一起看，可以比较直观的了解各个类的作用。LocalDate是表示日期的类，LocalTime表示时间，LocalDateTime则表示日期和时间的组合。
使用这几个类创建一个表示日期、时间和日期时间组合的对象也非常直观，注释是打印后的结果：
LocalDate.of(2020, 1, 1);// 2020-01-01 LocalTime.of(0, 0);// 00:00 LocalDateTime.of(2020, 1, 1, 0, 0);// 2020-01-01T00:00 LocalDate.parse(&amp;#34;2020-01-01&amp;#34;);// 2020-01-01 LocalTime.parse(&amp;#34;00:00:00&amp;#34;);// 00:00 LocalDateTime.parse(&amp;#34;2020-01-01T00:00:00&amp;#34;);// 2020-01-01T00:00 这些类不仅使用起来很直观，toString()的结果也很容易看懂。如果要打印Date对象，总是免不了要借助DateFormat类来使打印更容易读懂。需要注意的是，LocalDateTime默认是使用ISO 8601标准，跟国内显示常用的会有些差别。
新的API修改时间也很方便和直观，能直接修改时间的每个节点，也能以某个时间为基点，相对地增加或减少时间，并且每次修改都会返回一个新的对象：
//直接修改 LocalDateTime.parse(&amp;#34;2020-01-01T00:00:00&amp;#34;) .withYear(2010) .withMonth(6) .withDayOfMonth(16);//2010-06-16T00:00 //相对修改 LocalDateTime localDateTime = LocalDateTime.parse(&amp;#34;2020-01-01T00:00:00&amp;#34;); localDateTime.plusDays(6);// 2020-01-07T00:00 localDateTime.plusHours(6);// 2020-01-01T06:00 localDateTime.minusDays(1);// 2019-12-31T00:00 如果有较为复杂的时间修改操作，可以使用TemporalAdjuster类。它的辅助类TemporalAdjusters定义了大量内置常见的复杂修改时间的操作。如果这些内置的方式不能满足需求，也可以自行实现TemporalAdjuster类。
Instant Instant类主要用于描述从Unix元年开始计算的时间，与System.currentTimeMillis()比起来，除了能使用Instant.now().toEpochMilli()来表示Unix元年到现在经过的毫秒数，也能方便使用Instant.now().getEpochSecond()来表示经过秒数，还能使用多种方便的语义化操作。
Duration和Period 这两个对象都是用于表示两个时间的差值，不同点在于Duration不支持LocalDate的差值计算，只支持LocalTime、LocalDateTime和Instant的差值计算。而Period只支持LocalDate的差值计算。一般来说，Duration用于计算两个时间相差的天数、小时数、分钟数、秒数、毫秒数和纳秒数，而Period用于计算相差的天数、月数和年数，如：</description></item><item><title>动手实现:用Java实现一个简单的LinkedList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</link><pubDate>Sat, 24 Aug 2019 17:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</guid><description>概述 LinkedList也是List接口的一个实现，采用线性链表存储元素。本文尝试编写一个简单的LinkedList实现，通过对比来理解JDK中的LinkedList是如何实现的。本次主要实现LinkedList的一些常用方法。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。
然后再看一下get方法的实现
@SuppressWarnings(&amp;#34;unchecked&amp;#34;) @Override public E get(int index) { if(index &amp;lt; 0 || index &amp;gt;= size){ throw new IndexOutOfBoundsException(&amp;#34;索引越界&amp;#34;); } return (E) data[index]; } get方法的实现比较简单，首先检查一下传入索引的合法性，然后再返回数组中对应索引的元素。</description></item><item><title>动手实现:用Java实现一个简单的ArrayList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</link><pubDate>Thu, 30 May 2019 23:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</guid><description>概述 ArrayList是一个可以自动扩容的List接口实现，由命名可以看出是由数组实现。本文尝试编写一个简单的ArrayList实现，通过对比来理解JDK中的ArrayList是如何实现的。本次主要实现ArrayList的常用方法，完成简单的CRUD和迭代器。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。
然后再看一下get方法的实现
@SuppressWarnings(&amp;#34;unchecked&amp;#34;) @Override public E get(int index) { if(index &amp;lt; 0 || index &amp;gt;= size){ throw new IndexOutOfBoundsException(&amp;#34;索引越界&amp;#34;); } return (E) data[index]; } get方法的实现比较简单，首先检查一下传入索引的合法性，然后再返回数组中对应索引的元素。</description></item><item><title>使用Docker部署Spring Cloud</title><link>https://g.nereusyi.com/post/dockerize-spring-cloud/</link><pubDate>Sat, 20 Apr 2019 12:41:46 +0800</pubDate><guid>https://g.nereusyi.com/post/dockerize-spring-cloud/</guid><description>内容简介 这篇文章主要介绍如何使用Docker来部署一套基本的Spring Cloud环境，包含服务发现和服务调用，主要是展示Spring Cloud 和Docker是如何配合使用的。Docker和Spring Cloud都是使用基础组件。
环境 Java 8 CentOS 7.2 Spring Cloud 组件 Spring Cloud分为3个工程：
discovery service1 service2 discovery 这个工程主要用于服务注册，相关文件代码如下：
启动类DiscoveryApplication
@EnableEurekaServer @SpringBootApplication public class DiscoveryApplication { public static void main(String[] args) { SpringApplication.run(DiscoveryApplication.class, args); } } 配置文件application.yml
spring: application: name: discovery eureka: client: service-url: defaultZone: http://discovery:8080/eureka/ register-with-eureka: false fetch-registry: false service1 启动类Service1Application
@SpringBootApplication @EnableDiscoveryClient @RestController public class Service1Application { public static void main(String[] args) { SpringApplication.</description></item></channel></rss>