<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>example on NereusYi</title><link>https://g.nereusyi.com/categories/example/</link><description>Recent content in example on NereusYi</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 07 Dec 2019 13:28:09 +0800</lastBuildDate><atom:link href="https://g.nereusyi.com/categories/example/index.xml" rel="self" type="application/rss+xml"/><item><title>Orika使用实例</title><link>https://g.nereusyi.com/post/2019/orika-example/</link><pubDate>Sat, 07 Dec 2019 13:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/orika-example/</guid><description>简述 在项目中使用过不少Java Bean映射（Java Bean属性拷贝）类库，比如Apache和Spring的BeanUtils，cglib的BeanCopier等。 Apache和Spring的BeanUtils没有对list拷贝的内置支持，对属性不同类型的转换也缺乏默认的支持，需要做不少封装。 cglib的BeanCopier的API相对来说比较难使用，虽然速度极快，但需要做更多的封装，可读性不好。
综合下来，发现Orika能较好的满足各项常见的Java Bean映射需求。
使用实例 在实际使用中，通常可以把Orika封装成一个静态工具类，示例如下：
public class BeanMapperUtils { private static final DefaultMapperFactory mapperFactory ; private static final MapperFacade mapper; static { mapperFactory = new DefaultMapperFactory.Builder().build(); mapper = mapperFactory.getMapperFacade(); } public static &amp;lt;S, D&amp;gt; D map(S s, Class&amp;lt;D&amp;gt; aClass) { return mapper.map(s, aClass); } public static &amp;lt;S, D&amp;gt; List&amp;lt;D&amp;gt; mapAsList(Iterable&amp;lt;S&amp;gt; iterable, Class&amp;lt;D&amp;gt; aClass) { return mapper.mapAsList(iterable, aClass); } } MapperFactory和MapperFacade都是线程安全的，可以使用单例模式。详情可参考官方文档的Use the MapperFactory as a singleton章节。</description></item></channel></rss>