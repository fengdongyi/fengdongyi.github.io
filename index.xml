<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NereusYi</title><link>https://g.nereusyi.com/</link><description>Recent content on NereusYi</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 05 Feb 2020 21:28:09 +0800</lastBuildDate><atom:link href="https://g.nereusyi.com/index.xml" rel="self" type="application/rss+xml"/><item><title>visualvm的profiler连接问题</title><link>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</link><pubDate>Wed, 05 Feb 2020 21:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</guid><description>在 Windows 10 上，用JDK8 自带的jvisualvm.exe连接java程序，出现了几个问题。
问题1：选择profiler分析的时候，一直卡在“正在连接目标VM”： 解决：在命令行中用以下命令启动：
jvisualvm.exe -J-Dorg.netbeans.profiler.separateConsole=true 用这个方法启动过一次，第二次就可以直接双击启动，不用再从命令行启动了。
问题2：使用上面方法启动之后，再次选择profiler分析，出现Redefinition failed with error 62 解决：在被分析的程序启动时，加上JVM参数：-Xverify:none。
JDK内置的visualvm版本比较老，以上问题在我从官网上下载新的1.4.4版本的visualvm后都正常了。在JDK9之后，JDK也不再内置visualvm，所以还是单独下一个备着会比较好。
参考：
https://stackoverflow.com/questions/37632783/visualvm-cpu-memory-profiler-stuck-at-connecting-to-the-target-jvm
https://github.com/oracle/visualvm/issues/33
https://visualvm.github.io
https://blogs.oracle.com/java-platform-group/visual-vm-in-jdk-9-and-beyond</description></item><item><title>Orika使用实例</title><link>https://g.nereusyi.com/post/2019/orika-example/</link><pubDate>Sat, 07 Dec 2019 13:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/orika-example/</guid><description>简述 在项目中使用过不少Java Bean映射（Java Bean属性拷贝）类库，比如Apache和Spring的BeanUtils，cglib的BeanCopier等。 Apache和Spring的BeanUtils没有对list拷贝的内置支持，对属性不同类型的转换也缺乏默认的支持，需要做不少封装。 cglib的BeanCopier的API相对来说比较难使用，虽然速度极快，但需要做更多的封装，可读性不好。
综合下来，发现Orika能较好的满足各项常见的Java Bean映射需求。
使用实例 在实际使用中，通常可以把Orika封装成一个静态工具类，示例如下：
public class BeanMapperUtils { private static final DefaultMapperFactory mapperFactory ; private static final MapperFacade mapper; static { mapperFactory = new DefaultMapperFactory.Builder().build(); mapper = mapperFactory.getMapperFacade(); } public static &amp;lt;S, D&amp;gt; D map(S s, Class&amp;lt;D&amp;gt; aClass) { return mapper.map(s, aClass); } public static &amp;lt;S, D&amp;gt; List&amp;lt;D&amp;gt; mapAsList(Iterable&amp;lt;S&amp;gt; iterable, Class&amp;lt;D&amp;gt; aClass) { return mapper.mapAsList(iterable, aClass); } } MapperFactory和MapperFacade都是线程安全的，可以使用单例模式。详情可参考官方文档的Use the MapperFactory as a singleton章节。</description></item><item><title>Postman添加公共HTTP头</title><link>https://g.nereusyi.com/post/2019/postman-add-common-header/</link><pubDate>Sun, 08 Sep 2019 18:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/postman-add-common-header/</guid><description>postman添加公共HTTP头的方法如下：
1、在Collections下的文件夹右键，点击编辑
2、在Pre-request Scripts选项卡下，添加JS代码：
添加之后，对整个文件夹下的请求都有效
pm.request.headers.add({key: &#39;header_name&#39;, value: &#39;header_value&#39; }) pm.request.headers.upsert({key: &#39;header_name&#39;, value: &#39;header_value&#39; }) pm.request.headers.remove(&#39;header_name&#39;) 注意：如果需要看实际发送的请求参数，可以点工具栏的view-&amp;gt;Show Postman Console</description></item><item><title>动手实现:用Java实现一个简单的LinkedList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</link><pubDate>Sat, 24 Aug 2019 17:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</guid><description>概述 LinkedList也是List接口的一个实现，采用线性链表存储元素。本文尝试编写一个简单的LinkedList实现，通过对比来理解JDK中的LinkedList是如何实现的。本次主要实现LinkedList的一些常用方法。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。</description></item><item><title>动手实现:用Java实现一个简单的ArrayList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</link><pubDate>Thu, 30 May 2019 23:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</guid><description>概述 ArrayList是一个可以自动扩容的List接口实现，由命名可以看出是由数组实现。本文尝试编写一个简单的ArrayList实现，通过对比来理解JDK中的ArrayList是如何实现的。本次主要实现ArrayList的常用方法，完成简单的CRUD和迭代器。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。</description></item><item><title>Spring Boot 2 启动流程解析</title><link>https://g.nereusyi.com/post/2019/how-spring-boot-2-started-up/</link><pubDate>Sun, 19 May 2019 16:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/how-spring-boot-2-started-up/</guid><description>本文基于Spring Boot 2.1.4.RELEASE版本，希望通过&amp;rdquo;自顶向下&amp;rdquo;的方法来理解Spring Boot的启动流程。先从整体上了解流程走向，再查看对应源码。
启动类 Spring Boot的启动类通常如下：
@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 首先看一下@SpringBootApplication注解，这个注解由3个注解组成 @SpringBootApplication=@EnableAutoConfiguration+@ComponentScan+@Configuration
注意： @SpringBootApplication实际上注册的是@SpringBootConfiguration，但@SpringBootConfiguration里面包含了@Configuration。
各个注解作用如下：
@EnableAutoConfiguration 开启自动配置 @ComponentScan SpringBean扫描 @Configuration 开启配置类 然后再看一下SpringApplication类，这个类主要通过如下步骤启动应用： - 根据应用的classpath创建对应的ApplicationContext(独立应用、WEB应用或REACTIVE应用) - 注册CommandLinePropertySource，把命令行参数转换为Spring Properties - 刷新ApplicationContext，加载所有的单例SpringBean - 调用实现了CommandLineRunner的SpringBean中的run方法
下面从源码上分别来看下这些步骤，这些步骤主要在SpringApplication类中的run方法中(public ConfigurableApplicationContext run(String... args))
主要源码如下
代码清单1，创建SpringApplication实例
public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &amp;quot;PrimarySources must not be null&amp;quot;); this.</description></item><item><title>Docker基础总结</title><link>https://g.nereusyi.com/post/2019/docker-basic/</link><pubDate>Sun, 28 Apr 2019 22:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/docker-basic/</guid><description>对开发者来说，了解一些Docker基础用法和原理有不少好处，比如在开发机上使用Docker，解决“我的机子上运行没问题”这样的情况，技术选型等。下面总结了一些常用概念和命令，其中还包含一些个人的理解，随着越来越深入的使用，本文也会持续更新。
Docker概况 Docker是什么 Docker是一个操作系统级的虚拟化容器平台，用Go语言实现。Docker主要用于部署和运行应用，并包含应用的所有依赖。通过Docker，可以在一台主机上隔离多个应用，以及确保应用能在不同环境下以相同方式运行。
Docker目前有两种版本
Community Edition (CE) Enterprise Edition (EE) Docker引擎(Docker Engine) Docker引擎是Docker的主要核心，采用C/S结构，包含以下组件
docker daemon
docker daemon是一个在后台运行的服务，用于创建和管理docker组件，比如：镜像、容器、网络和数据卷 docker REST API
docker REST API用来控制docker daemon docker CLI
docker CLI是命令行工具(平常用的docker命令)，docker CLI是通过docker REST API、脚本或直接通过docker daemon命令来控制docker daemon Docker组件 Docker主要组件有
镜像(image) 容器(container) 网络(network) 存储(storage) 镜像 镜像是构建容器的模版。一个镜像包含应用和应用运行所需要的所有依赖。可以通过registry存储和分发，registry是一个类似maven仓库的服务。
容器 容器是镜像的一个运行实例。可以从一个镜像中创建多个容器。如果删除一个容器，那么容器内的数据也会被删除。
可以把Docker镜像想象成虚拟机的快照，而容器就是通过快照创建的虚拟机。
也可以把镜像想象成Java中的类，而容器就是类的实例对象。
网络 Docker安装之后默认有三种网络:none,bridge和host。
存储 默认情况下，当容器被删除的时候，容器里的数据也会跟着容器被删除，同时想要转移容器内的数据也不容易。Docker有以下几种持久化存储的选择 - 数据卷(Data Volumes) - 数据卷容器(Data Volume Container) - 直接挂载主机目录(Directory Mounts) - 存储插件(Storage Plugins)</description></item><item><title>使用Docker部署Spring Cloud</title><link>https://g.nereusyi.com/post/dockerize-spring-cloud/</link><pubDate>Sat, 20 Apr 2019 12:41:46 +0800</pubDate><guid>https://g.nereusyi.com/post/dockerize-spring-cloud/</guid><description>内容简介 这篇文章主要介绍如何使用Docker来部署一套基本的Spring Cloud环境，包含服务发现和服务调用，主要是展示Spring Cloud 和Docker是如何配合使用的。Docker和Spring Cloud都是使用基础组件。
环境 Java 8 CentOS 7.2 Spring Cloud 组件 Spring Cloud分为3个工程：
discovery service1 service2 discovery 这个工程主要用于服务注册，相关文件代码如下：
启动类DiscoveryApplication
@EnableEurekaServer @SpringBootApplication public class DiscoveryApplication { public static void main(String[] args) { SpringApplication.run(DiscoveryApplication.class, args); } } 配置文件application.yml
spring: application: name: discovery eureka: client: service-url: defaultZone: http://discovery:8080/eureka/ register-with-eureka: false fetch-registry: false service1 启动类Service1Application
@SpringBootApplication @EnableDiscoveryClient @RestController public class Service1Application { public static void main(String[] args) { SpringApplication.</description></item><item><title>新站点</title><link>https://g.nereusyi.com/post/new-website/</link><pubDate>Sun, 14 Apr 2019 16:26:25 +0800</pubDate><guid>https://g.nereusyi.com/post/new-website/</guid><description>本站点采用HUGO生成。在这之前用过不少博客平台，记得最开始开通博客大概在高中，那时候用的是百度空间，文笔不算好，所以博文都还是转载的多，也在上面认识了不少人。之后过了不久，百度空间被关闭了。
然后下一个用的博客是网易163博客，用了一段时间之后就懒了，一直没更新，最近上去发现163博客也要被关闭了，变成了lofter提供服务。
刚开始参加工作的时候，用了OSC的博客，虽然文笔还是一样不好，但还是发表了一些博文，不过发表的博文数量并不多，内容多半是记录和学习笔记。
目前除了这个站点，还有使用Blogger。</description></item></channel></rss>