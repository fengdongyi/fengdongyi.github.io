<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NereusYi</title><link>https://g.nereusyi.com/</link><description>Recent content on NereusYi</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 30 Aug 2020 19:55:06 +0800</lastBuildDate><atom:link href="https://g.nereusyi.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Java NIO File API使用总结</title><link>https://g.nereusyi.com/post/2020/08/java-file-nio-demo/</link><pubDate>Sun, 30 Aug 2020 19:55:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/08/java-file-nio-demo/</guid><description>简介 Java I/O File API是JDK的核心API之一，在构建系统时，十分常用。我在工作实践中，见到大多数人最常使用的是java.io.File的API，对Java7之后出现的NIO的API不太熟悉。
总的来说，File能实现的功能NIO都能实现，并且NIO API更好用、更方便，同时内置了不少工具类，也解决了File API的一些缺陷。
根据实际工作中的使用和一些文档，本文总结了一些常见的Java File NIO的用法。
File的缺陷 File API比较简单好用，能完成大部分功能，但使用上有不少的问题，比如：
大多数方法出错不抛出异常 比如：删除new File(&amp;quot;1111.txt&amp;quot;).delete()，如果删除失败，delete方法只会返回一个false，开发者没办法知道具体原因，比如是因为没权限，还是因为文件已被删除？ 不支持软链接，这会导致有某些情况下没办法遍历目录 文件的元数据支持较少，比如缺少文件的权限、安全属性等 等等。
File和Path java.nio.file.Path是Java7中用于替代File的新API，File和Path的概念相似，都是表示一个文件或文件夹的抽象。实际上，也可以把Path当成新API中的File。
FIle与Path的主要区别：
File是实体类，Path是接口，使得Path更符合面向对象的设计原则。 File独立于文件系统，Path与文件系统相关，以及Path能给出更多关于文件的信息。 新写的代码最好就开始使用Path，有需要与File交互的地方，可以使用FIle与Path相互转换方法：
Path path = new File(DEMO_PATH).toPath(); File file = path.toFile(); Path的基本操作 创建Path URI uri = new URI(&amp;quot;file:///&amp;quot; + DEMO_PATH); // method 1 Path path1 = Paths.get(DEMO_PATH); // method 2 Path path2 = Paths.get(uri); // method 3 Path path3 = Path.</description></item><item><title>在Docker中安装并设置Jenkins</title><link>https://g.nereusyi.com/post/2020/08/devops-setup-jenkins-in-docker/</link><pubDate>Sun, 09 Aug 2020 13:20:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/08/devops-setup-jenkins-in-docker/</guid><description>简介 相比在主机中直接安装各种基础服务，在Docker中安装和升级都更方便，也更不容易破坏其他的基础服务。下面总结一下Jenkins在Docker中的使用。
安装并运行Jenkins 安装并运行命令如下：
docker run -d -u root --restart always --name jenkins \ -e &amp;quot;JAVA_OPTS=-Dorg.apache.commons.jelly.tags.fmt.timeZone=Asia/Shanghai -Duser.timezone=Asia/Shanghai -Dorg.apache.commons.jelly.tags.fmt.timeZone=Asia/Shanghai&amp;quot; \ --group-add $(stat -c &#39;%g&#39; /var/run/docker.sock) \ -v /etc/localtime:/etc/localtime:ro \ -v /opt/data/jenkins/workspace/:/usr/src/app \ -v /var/run/docker.sock:/var/run/docker.sock \ -v $(which docker):$(which docker) \ -v /data/jenkins:/var/jenkins_home \ -v /data/jenkins_tool:/jenkins_tool \ -v /data/jenkins_tool/repo:/repo \ -p 8099:8080 -p 50000:50000 \ jenkins/jenkins:lts Jenkins的Docker官方镜像中有很多参数的解释，这里列出其中一些参数以及使用原因：
-u root使用root启动镜像中的Jenkins服务，会有一定安全风险，但权限方面会方便很多，也考虑到是在内网中运行所以问题不大
-e xxxxxxxx和-v /etc/localtime:/etc/localtime:ro设置Jenkins的时区
-v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):$(which docker)这两条参数让在Docker中的Jenkins也能访问宿主机中的Docker，让项目的构建环境（如maven、node）也能够在Docker中运行构建
-p 50000:50000用于与Jenkins slave通信</description></item><item><title>个人常用IntelliJ IDEA插件</title><link>https://g.nereusyi.com/post/2020/03/java-intellij-idea-plugin/</link><pubDate>Sat, 21 Mar 2020 18:50:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/03/java-intellij-idea-plugin/</guid><description>由于常用Windows，所以快捷键的说明都是基于Windows。
Maven Helper 基于Maven的Java开发必备，能列出依赖冲突项、列出全部依赖和按树状列出依赖。 插件地址：https://plugins.jetbrains.com/plugin/7179-maven-helper
Request mapper Spring MVC / Spring Boot开发必备，能根据RequestMapping的URL来搜索对应的方法。默认快捷键:可以直接双击Shift搜索，也可以用&amp;rdquo; Ctrl + Shift + \ &amp;ldquo;。 插件地址：https://plugins.jetbrains.com/plugin/9567-request-mapper
String Manipulation 常见字符串格式的相互转换，对字符串的操作。对我个人来说，对接口文档的时候会很方便，从文档上复制下来的变量名格式，可以批量转换成Java的驼峰格式，或者数据库的下划线格式。默认快捷键是：&amp;rdquo;alt + M&amp;rdquo; 和 &amp;ldquo;alt + shift + M&amp;rdquo;
插件地址：https://plugins.jetbrains.com/plugin/2162-string-manipulation
Grazie 语法检查插件，能避免常见的语法错误。 插件地址：https://plugins.jetbrains.com/plugin/12175-grazie
Free MyBatis plugin Mybatis开发插件，可以从代码调用的地方，直接跳转到XML文件对应方法。 插件地址：https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin
Rainbow Brackets 为括号使用不同的颜色区分，写代码的时候能更直观的区分括号对。 插件地址：https://plugins.jetbrains.com/plugin/10080-rainbow-brackets
Nyan Progress Bar 这是个挺有意思的进度条美化插件。 插件地址：https://plugins.jetbrains.com/plugin/8575-nyan-progress-bar</description></item><item><title>Java8:Time API使用总结</title><link>https://g.nereusyi.com/post/2020/03/java-8-time-api-example/</link><pubDate>Tue, 17 Mar 2020 22:25:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/03/java-8-time-api-example/</guid><description>简介 Java8已经出了很长一段时间，主流的第三方库也都基本已经支持新的Time API，但是见到不少开发还是习惯用Date和Calendar，所以在这篇文章里总结如何使用这个新的Time API，以及旧API的一些设计上的缺陷和使用上的不便。
Date和Calendar的设计 Date设计的开始年份是1900年，月份是从0开始，日又是从1开始，所以想要创建一个2020年1月1日的Date对象得这样：
new Date(120,0,1); 这行代码很难直观看出是想要创建什么时候的Date对象，使用起来十分不便。
Calendar设计年份要好一些，去掉了从1900年开始的设计，但是月份还是从0开始计算，使用起来也是不那么直观：
Calendar calendar = Calendar.getInstance(); calendar.set(2020, 0, 1,0,0,0); 这样的设计和API的不一致，导致不少功能需要各个项目使用utils类来重复实现，或者是使用Joda-Time这样的第三方库。
好在Java8推出了新的Time API，JSR-310来解决这样的情况。新的API与Joda-Time比较相似，但也有一些新的设计。具体可以查看Stephen Colebourne的文章[1]。
Java8的TimeAPI的使用 这一节总结Time包下各个API的使用。
LocalDate、LocalTime和LocalDateTime 这几个类名取得比较好，把这几个类的名字合在一起看，可以比较直观的了解各个类的作用。LocalDate是表示日期的类，LocalTime表示时间，LocalDateTime则表示日期和时间的组合。
使用这几个类创建一个表示日期、时间和日期时间组合的对象也非常直观，注释是打印后的结果：
LocalDate.of(2020, 1, 1);// 2020-01-01 LocalTime.of(0, 0);// 00:00 LocalDateTime.of(2020, 1, 1, 0, 0);// 2020-01-01T00:00 LocalDate.parse(&amp;quot;2020-01-01&amp;quot;);// 2020-01-01 LocalTime.parse(&amp;quot;00:00:00&amp;quot;);// 00:00 LocalDateTime.parse(&amp;quot;2020-01-01T00:00:00&amp;quot;);// 2020-01-01T00:00 这些类不仅使用起来很直观，toString()的结果也很容易看懂。如果要打印Date对象，总是免不了要借助DateFormat类来使打印更容易读懂。需要注意的是，LocalDateTime默认是使用ISO 8601标准，跟国内显示常用的会有些差别。
新的API修改时间也很方便和直观，能直接修改时间的每个节点，也能以某个时间为基点，相对地增加或减少时间，并且每次修改都会返回一个新的对象：
//直接修改 LocalDateTime.parse(&amp;quot;2020-01-01T00:00:00&amp;quot;) .withYear(2010) .withMonth(6) .withDayOfMonth(16);//2010-06-16T00:00 //相对修改 LocalDateTime localDateTime = LocalDateTime.parse(&amp;quot;2020-01-01T00:00:00&amp;quot;); localDateTime.plusDays(6);// 2020-01-07T00:00 localDateTime.plusHours(6);// 2020-01-01T06:00 localDateTime.minusDays(1);// 2019-12-31T00:00 如果有较为复杂的时间修改操作，可以使用TemporalAdjuster类。它的辅助类TemporalAdjusters定义了大量内置常见的复杂修改时间的操作。如果这些内置的方式不能满足需求，也可以自行实现TemporalAdjuster类。</description></item><item><title>Java微型网络程序GC调优练习</title><link>https://g.nereusyi.com/post/2020/02/gc-tuning-practice/</link><pubDate>Mon, 10 Feb 2020 20:15:06 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/02/gc-tuning-practice/</guid><description>简介 最近用java写了一个微型的网络程序，没进行GC调优的情况下就已经满足性能要求。不过想通过对这个程序调优，再熟悉一下GC调优流程。
通过活跃数据大小设置堆内存大小 活跃数据大小指的是应用程序员运行于稳定态时，长期存活的对象在Java堆中占用的空间大小。所以可以在程序稳定运行时，进行多次Full GC，之后再查看Java堆的占用情况来测量活跃数据大小。
调优过程需要一步一步多次确定更合适的值，JVM的初始参数和版本信息如下（堆大小按感觉先随意分配256M，如果有溢出再调整）：
-Xms256m -Xmx256m -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:MaxDirectMemorySize=512m -XX:+PrintCommandLineFlags -XX:+UseParallelGC java version &amp;quot;1.8.0_241&amp;quot; Java(TM) SE Runtime Environment (build 1.8.0_241-b07) Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode) 其中-XX:+PrintGCDetails参数表示打印垃圾回收情况，-XX:+PrintGCTimeStamps参数表示每次打印的时候带上JVM启动到当前时间的秒数，也可以使用-XX:+PrintGCDateStamps打印日历时间。-XX:+UseParallelGC是java8在Windows64上的默认选择，表示同时启用多线程新生代和多线程老年代的Parallel垃圾收集器[1]，这一点可能跟旧版本的java不一样（对旧版本java的没太多研究）。
用这个程序来看平均速率在200KB/S左右的直播。运行一段时间之后，程序达到稳定状态。由于这个程序在256M内存下，不经常发生Full GC，所以在程序稳定运行的时候，用visualvm触发多次Full GC。每次Full GC的结果比较相似，选取其中一个显示如下（已调整换行）：
1887.144: [Full GC (System.gc()) [PSYoungGen: 224K-&amp;gt;0K(86528K)] [ParOldGen: 7438K-&amp;gt;6220K(175104K)] 7662K-&amp;gt;6220K(261632K), [Metaspace: 19356K-&amp;gt;19356K(1067008K)], 0.0254513 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] 日志显示，Full GC之后的老年代占用6220K，所以活跃数据大约为6M。根据通用法则，堆的初始值和最大值一般设置为老年代活跃数据大小的3-4倍。这里按4倍计算，设置堆的初始值和最大值为24M：-Xms24m -Xmx24m。
而新生代的空间应该为老年代活跃数据的1-1.5倍。这里按1.5倍计算，设置新生代大小为9M：-Xmn9m。调整后使用的JVM参数设置如下：
-Xms24m -Xmx24m -Xmn9m -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:MaxDirectMemorySize=512m -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC 验证设置 经过设置之后，再次让程序运行到稳定的状态。其中Minor GC的频率比较稳定，摘取结果如下：</description></item><item><title>visualvm的profiler连接问题</title><link>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</link><pubDate>Wed, 05 Feb 2020 21:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2020/02/visualvm-profiler-startup-problem/</guid><description>在 Windows 10 上，用JDK8 自带的jvisualvm.exe连接java程序，出现了几个问题。
问题1：选择profiler分析的时候，一直卡在“正在连接目标VM”： 解决：在命令行中用以下命令启动：
jvisualvm.exe -J-Dorg.netbeans.profiler.separateConsole=true 用这个方法启动过一次，第二次就可以直接双击启动，不用再从命令行启动了。
问题2：使用上面方法启动之后，再次选择profiler分析，出现Redefinition failed with error 62 解决：在被分析的程序启动时，加上JVM参数：-Xverify:none。
JDK内置的visualvm版本比较老，以上问题在我从官网上下载新的1.4.4版本的visualvm后都正常了。在JDK9之后，JDK也不再内置visualvm，所以还是单独下一个备着会比较好。
参考：
https://stackoverflow.com/questions/37632783/visualvm-cpu-memory-profiler-stuck-at-connecting-to-the-target-jvm
https://github.com/oracle/visualvm/issues/33
https://visualvm.github.io
https://blogs.oracle.com/java-platform-group/visual-vm-in-jdk-9-and-beyond</description></item><item><title>Orika使用实例</title><link>https://g.nereusyi.com/post/2019/orika-example/</link><pubDate>Sat, 07 Dec 2019 13:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/orika-example/</guid><description>简述 在项目中使用过不少Java Bean映射（Java Bean属性拷贝）类库，比如Apache和Spring的BeanUtils，cglib的BeanCopier等。 Apache和Spring的BeanUtils没有对list拷贝的内置支持，对属性不同类型的转换也缺乏默认的支持，需要做不少封装。 cglib的BeanCopier的API相对来说比较难使用，虽然速度极快，但需要做更多的封装，可读性不好。
综合下来，发现Orika能较好的满足各项常见的Java Bean映射需求。
使用实例 在实际使用中，通常可以把Orika封装成一个静态工具类，示例如下：
public class BeanMapperUtils { private static final DefaultMapperFactory mapperFactory ; private static final MapperFacade mapper; static { mapperFactory = new DefaultMapperFactory.Builder().build(); mapper = mapperFactory.getMapperFacade(); } public static &amp;lt;S, D&amp;gt; D map(S s, Class&amp;lt;D&amp;gt; aClass) { return mapper.map(s, aClass); } public static &amp;lt;S, D&amp;gt; List&amp;lt;D&amp;gt; mapAsList(Iterable&amp;lt;S&amp;gt; iterable, Class&amp;lt;D&amp;gt; aClass) { return mapper.mapAsList(iterable, aClass); } } MapperFactory和MapperFacade都是线程安全的，可以使用单例模式。详情可参考官方文档的Use the MapperFactory as a singleton章节。</description></item><item><title>Postman添加公共HTTP头</title><link>https://g.nereusyi.com/post/2019/postman-add-common-header/</link><pubDate>Sun, 08 Sep 2019 18:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/postman-add-common-header/</guid><description>postman添加公共HTTP头的方法如下：
1、在Collections下的文件夹右键，点击编辑
2、在Pre-request Scripts选项卡下，添加JS代码：
添加之后，对整个文件夹下的请求都有效
pm.request.headers.add({key: &#39;header_name&#39;, value: &#39;header_value&#39; }) pm.request.headers.upsert({key: &#39;header_name&#39;, value: &#39;header_value&#39; }) pm.request.headers.remove(&#39;header_name&#39;) 注意：如果需要看实际发送的请求参数，可以点工具栏的view-&amp;gt;Show Postman Console</description></item><item><title>动手实现:用Java实现一个简单的LinkedList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</link><pubDate>Sat, 24 Aug 2019 17:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-linkedlist/</guid><description>概述 LinkedList也是List接口的一个实现，采用线性链表存储元素。本文尝试编写一个简单的LinkedList实现，通过对比来理解JDK中的LinkedList是如何实现的。本次主要实现LinkedList的一些常用方法。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。</description></item><item><title>动手实现:用Java实现一个简单的ArrayList</title><link>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</link><pubDate>Thu, 30 May 2019 23:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/implements-a-simple-arraylist/</guid><description>概述 ArrayList是一个可以自动扩容的List接口实现，由命名可以看出是由数组实现。本文尝试编写一个简单的ArrayList实现，通过对比来理解JDK中的ArrayList是如何实现的。本次主要实现ArrayList的常用方法，完成简单的CRUD和迭代器。
动手实现 成员变量和构造方法 首先看一下类声明，为了更方便实现列表的相关方法，以及面向接口编程，这里声明实现List接口，类命名为SimpleArrayList
public class SimpleArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {} 然后再看一下成员变量，这里设计两个成员变量，第一个变量是实际存储数据的数组，第二个变量是数据的大小
private Object[] data; private int size; 然后在构造方法中初始化数组
public SimpleArrayList() { data = new Object[10]; } CRUD的实现 首先看一下add方法实现
@Override public boolean add(E e) { //判断数组还有没有空间存放新的元素 if( (size + 1) &amp;gt; data.length){ Object[] newData = new Object[data.length + 10]; System.arraycopy(data, 0, newData, 0, data.length); data = newData; } data[size++] = e; return true; } 方法先判断数组中还有没有足够空间存放新元素。如果没有足够空间，就创建一个新数组，长度在原来的基础上增加10，再把原来数组的内容拷贝到新数组里，最后把新数组赋值给实际存储数据的成员变量data，这样就完成了扩容。最后再把add的元素放在最后一位，这样add方法就完成了。</description></item><item><title>Spring Boot 2 启动流程解析</title><link>https://g.nereusyi.com/post/2019/how-spring-boot-2-started-up/</link><pubDate>Sun, 19 May 2019 16:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/how-spring-boot-2-started-up/</guid><description>本文基于Spring Boot 2.1.4.RELEASE版本，希望通过&amp;rdquo;自顶向下&amp;rdquo;的方法来理解Spring Boot的启动流程。先从整体上了解流程走向，再查看对应源码。
启动类 Spring Boot的启动类通常如下：
@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 首先看一下@SpringBootApplication注解，这个注解由3个注解组成 @SpringBootApplication=@EnableAutoConfiguration+@ComponentScan+@Configuration
注意： @SpringBootApplication实际上注册的是@SpringBootConfiguration，但@SpringBootConfiguration里面包含了@Configuration。
各个注解作用如下：
@EnableAutoConfiguration 开启自动配置 @ComponentScan SpringBean扫描 @Configuration 开启配置类 然后再看一下SpringApplication类，这个类主要通过如下步骤启动应用： - 根据应用的classpath创建对应的ApplicationContext(独立应用、WEB应用或REACTIVE应用) - 注册CommandLinePropertySource，把命令行参数转换为Spring Properties - 刷新ApplicationContext，加载所有的单例SpringBean - 调用实现了CommandLineRunner的SpringBean中的run方法
下面从源码上分别来看下这些步骤，这些步骤主要在SpringApplication类中的run方法中(public ConfigurableApplicationContext run(String... args))
主要源码如下
代码清单1，创建SpringApplication实例
public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &amp;quot;PrimarySources must not be null&amp;quot;); this.</description></item><item><title>Docker基础总结</title><link>https://g.nereusyi.com/post/2019/docker-basic/</link><pubDate>Sun, 28 Apr 2019 22:28:09 +0800</pubDate><guid>https://g.nereusyi.com/post/2019/docker-basic/</guid><description>对开发者来说，了解一些Docker基础用法和原理有不少好处，比如在开发机上使用Docker，解决“我的机子上运行没问题”这样的情况，技术选型等。下面总结了一些常用概念和命令，其中还包含一些个人的理解，随着越来越深入的使用，本文也会持续更新。
Docker概况 Docker是什么 Docker是一个操作系统级的虚拟化容器平台，用Go语言实现。Docker主要用于部署和运行应用，并包含应用的所有依赖。通过Docker，可以在一台主机上隔离多个应用，以及确保应用能在不同环境下以相同方式运行。
Docker目前有两种版本
Community Edition (CE) Enterprise Edition (EE) Docker引擎(Docker Engine) Docker引擎是Docker的主要核心，采用C/S结构，包含以下组件
docker daemon
docker daemon是一个在后台运行的服务，用于创建和管理docker组件，比如：镜像、容器、网络和数据卷 docker REST API
docker REST API用来控制docker daemon docker CLI
docker CLI是命令行工具(平常用的docker命令)，docker CLI是通过docker REST API、脚本或直接通过docker daemon命令来控制docker daemon Docker组件 Docker主要组件有
镜像(image) 容器(container) 网络(network) 存储(storage) 镜像 镜像是构建容器的模版。一个镜像包含应用和应用运行所需要的所有依赖。可以通过registry存储和分发，registry是一个类似maven仓库的服务。
容器 容器是镜像的一个运行实例。可以从一个镜像中创建多个容器。如果删除一个容器，那么容器内的数据也会被删除。
可以把Docker镜像想象成虚拟机的快照，而容器就是通过快照创建的虚拟机。
也可以把镜像想象成Java中的类，而容器就是类的实例对象。
网络 Docker安装之后默认有三种网络:none,bridge和host。
存储 默认情况下，当容器被删除的时候，容器里的数据也会跟着容器被删除，同时想要转移容器内的数据也不容易。Docker有以下几种持久化存储的选择 - 数据卷(Data Volumes) - 数据卷容器(Data Volume Container) - 直接挂载主机目录(Directory Mounts) - 存储插件(Storage Plugins)</description></item><item><title>使用Docker部署Spring Cloud</title><link>https://g.nereusyi.com/post/dockerize-spring-cloud/</link><pubDate>Sat, 20 Apr 2019 12:41:46 +0800</pubDate><guid>https://g.nereusyi.com/post/dockerize-spring-cloud/</guid><description>内容简介 这篇文章主要介绍如何使用Docker来部署一套基本的Spring Cloud环境，包含服务发现和服务调用，主要是展示Spring Cloud 和Docker是如何配合使用的。Docker和Spring Cloud都是使用基础组件。
环境 Java 8 CentOS 7.2 Spring Cloud 组件 Spring Cloud分为3个工程：
discovery service1 service2 discovery 这个工程主要用于服务注册，相关文件代码如下：
启动类DiscoveryApplication
@EnableEurekaServer @SpringBootApplication public class DiscoveryApplication { public static void main(String[] args) { SpringApplication.run(DiscoveryApplication.class, args); } } 配置文件application.yml
spring: application: name: discovery eureka: client: service-url: defaultZone: http://discovery:8080/eureka/ register-with-eureka: false fetch-registry: false service1 启动类Service1Application
@SpringBootApplication @EnableDiscoveryClient @RestController public class Service1Application { public static void main(String[] args) { SpringApplication.</description></item><item><title>新站点</title><link>https://g.nereusyi.com/post/new-website/</link><pubDate>Sun, 14 Apr 2019 16:26:25 +0800</pubDate><guid>https://g.nereusyi.com/post/new-website/</guid><description>本站点采用HUGO生成。在这之前用过不少博客平台，记得最开始开通博客大概在高中，那时候用的是百度空间，文笔不算好，所以博文都还是转载的多，也在上面认识了不少人。之后过了不久，百度空间被关闭了。
然后下一个用的博客是网易163博客，用了一段时间之后就懒了，一直没更新，最近上去发现163博客也要被关闭了，变成了lofter提供服务。
刚开始参加工作的时候，用了OSC的博客，虽然文笔还是一样不好，但还是发表了一些博文，不过发表的博文数量并不多，内容多半是记录和学习笔记。
目前除了这个站点，还有使用Blogger。</description></item></channel></rss>